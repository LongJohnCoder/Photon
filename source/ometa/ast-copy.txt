ometa PhotonASTCopy {
  trans      = [:t apply(t):ans]      -> ans,
  curlyTrans = [#begin curlyTrans:r]  -> [#begin, r]
             | [#begin trans*:rs]     -> [#begin].concat(rs)
             | trans:r,

  global   :ctxt trans:r                                  -> [#global, _deep_copy(ctxt), r],
  this end                                                -> [#this],    
  break end                                               -> [#break],
  continue end                                            -> [#continue],
  number   :n                                             -> [#number, _deep_copy(n)],
  string   :s                                             -> [#string, _deep_copy(s)],
  arr      trans*:xs                                      -> [#arr].concat(xs),
  unop     :op trans:x                                    -> [#unop, _deep_copy(op), x],
  getp     trans:fd trans:x                               -> [#getp, _deep_copy(fd), x],
  get      :x                                             -> [#get, _deep_copy(x)],
  set      trans:lhs trans:rhs                            -> [#set, lhs, rhs],
  mset     trans:lhs :op trans:rhs                        -> [#mset, lhs, _deep_copy(op), rhs],
  binop    :op trans:x trans:y                            -> [#binop, _deep_copy(op), x, y],
  preop    :op trans:x                                    -> [#preop, _deep_copy(op), x],
  postop   :op trans:x                                    -> [#postop, _deep_copy(op), x],
  return   trans:x                                        -> [#return, x],
  with     trans:x curlyTrans:s                           -> [#with, x, s],
  if       trans:cond curlyTrans:t curlyTrans:e           -> [#if, cond, t, e],
  condExpr trans:cond trans:t trans:e                     -> [#condExpr, cond, t, e],
  while    trans:cond curlyTrans:body                     -> [#while, cond, body],
  doWhile  curlyTrans:body trans:cond                     -> [#doWhile, body, cond],
  for      trans:init trans:cond trans:upd 
           curlyTrans:body                                -> [#for, init, cond, upd, body],
  forIn    trans:x trans:arr curlyTrans:body              -> [#forIn, x, arr, body],
  begin    trans:x end                                    -> [#begin, x],
  begin    trans*:xs                                      -> [#begin].concat(xs),
  func     :args :ctxt curlyTrans:body                    -> [#func, _deep_copy(args), _deep_copy(ctxt), body],  
  call     trans:fn trans*:args                           -> [#call, fn].concat(args),
  ccall    trans:fn trans*:args                           -> [#ccall, fn].concat(args),
  send     :msg trans:recv trans*:args                    -> [#send, _deep_copy(msg), recv].concat(args),
  new      trans:fn trans*:args                           -> [#new, fn].concat(args),
  var      :name trans:val                                -> [#var, _deep_copy(name), val],
  throw    trans:x                                        -> [#throw, x],
  try      curlyTrans:x :name curlyTrans:c curlyTrans:f   -> [#try, x, _deep_copy(name), c, f],
  json     trans*:props                                   -> [#json].concat(props),
  binding  :name trans:val                                -> [#binding, _deep_copy(name), val],
  switch   trans:x trans*:cases                           -> [#switch, x].concat(cases),
  case     trans:x trans:y                                -> [#case, x, y],
  default          trans:y                                -> [#default, y],

  global_return    trans:x                                -> [#global_return, x],
  ref      :s                                             -> [#ref, _deep_copy(s)],
  gets     trans:fd trans:x                               -> [#gets, fd, x],
  mreturn  trans:x trans:y                                -> [#mreturn, x, y],
  code     :c                                             -> [#code, _deep_copy(c)],
  super    trans:e                                        -> [#super, e],
  macro    :n :args :ctxt curlyTrans:body                 -> [#macro, _deep_copy(n), _deep_copy(args), _deep_copy(ctxt), body]
}

ometa PhotonMacroExp <: PhotonASTCopy {
  macro    :n  :args :ctxt :body                          -> {self.macros[n] = [#macro, n, args, ctxt, body]; 
                                                             [#get, "undefined"]},
  call     ([#get :x] ?(self.macros[x] !== undefined) 
           trans*:args                                    -> PhotonMacroRep.createInstance(args, self.macros).matchAll([self.macros[x]], "trans")
           | ^call)
}

PhotonMacroExp.initialize = function ()
{
    this.macros = {};
}

ometa PhotonMacroRep <: PhotonASTCopy {
  get      (:x ?(self.bindings[x] !== undefined)             -> self.bindings[x]
           | ^get),
             
  macro    :n  (:args -> self.bind(args)) :ctxt 
                  trans:body                                -> body,
  begin    [#return trans:x] end                            -> x,
  begin    trans:x end                                      -> [#begin, x],
  begin    trans*:xs                                        -> [#begin].concat(xs),
 
  // Recursively expand macro calls
  call     ([#get :x] ?(self.macros[x] !== undefined) 
           trans*:args                                      -> self.createInstance(args, self.macros).matchAll([self.macros[x]], "trans")
           | ^call)
}

PhotonMacroRep.initialize = function (args, macros)
{
    this.macro_actual_args = args;
    this.macros = macros;

    this.bindings = {};

    this.bind = function (args)
    {
        for (var i=0; i < args.length; ++i)
        {
            this.bindings[args[i]] = this.macro_actual_args[i];
        }
    }
}
