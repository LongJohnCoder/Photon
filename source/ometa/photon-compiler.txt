ometa PhotonParser <: Parser {
  fromTo :x :y = seq(x) (~seq(y) char)* seq(y), 
  fromTo2 :x :y = seq(x) (~seq(y) char)*:s seq(y) -> s.join(''), 
  space        = ^space | fromTo('//', '\n') | fromTo('/*', '*/'),
  ceval        = fromTo2('@{', '}@'):s                                               -> [#eval, s],
  nameFirst    = letter | '$' | '_',
  nameRest     = nameFirst | digit,
  iName        = firstAndRest(#nameFirst, #nameRest):r                               -> r.join(''),
  isKeyword :x = ?PhotonParser._isKeyword(x),
  name         = iName:n ~isKeyword(n)                                               -> [#name, n=='self' ? '$elf' : n],
  keyword      = iName:k isKeyword(k)                                                -> [k, k],
  hexDigit     = char:x {this.hexDigits.indexOf(x.toLowerCase())}:v ?(v >= 0)        -> v,
  hexLit       = hexLit:n hexDigit:d                                                 -> (n * 16 + d)
               | hexDigit,
  number       = ``0x'' hexLit:n                                                     -> [#number, n]
               | digit+:ws ('.' digit+ | empty -> []):fs                             -> [#number, parseFloat(ws.join('') + '.' +
                                                                                                             fs.join(''))],
  escapeChar   = '\\' char:c                                                         -> unescape('\\' + c),
  str          = seq('"""')  (escapeChar | ~seq('"""') char)*:cs seq('"""')          -> [#string, cs.join('')]
               | '\'' (escapeChar | ~'\'' char)*:cs '\''                             -> [#string, cs.join('')]
               | '"'  (escapeChar | ~'"'  char)*:cs '"'                              -> [#string, cs.join('')]
               | ('#' | '`') iName:n                                                 -> [#string, n],
  special      = ( '('   | ')'    | '{'    | '}'     | ``[@'' |'['      | ']'     | ','    
                 | ';'   | '?'    | ':'    | ``!=='' | ``!='' | ``==='' | ``==''
                 |``<<=''| ``<<'' |``>>>='' |``>>>'' |``>>=''  |``>>'' 
                 | ``='' | ``>='' | '>'    | ``<=''  | '<'    | ``++''  | ``+=''
                 | '+'   | ``--'' | ``-='' | '-'     | ``*='' | '*'     | ``/=''
                 | '/'   | ``%='' | '%'    | ``&&='' | ``&='' | ``&&''  | ``||='' 
                 | ``|=''| ``||''
                 | '.'   | '!'    | '|'    | '&'     | '^'    | '~'              ):s -> [s, s],
  tok          = spaces (ceval | name | keyword | number | str | special),
  toks         = token*:ts spaces end                                                -> ts,
  token :tt    = tok:t ?(t[0] == tt)                                                 -> t[1],
  spacesNoNl   = (~'\n' space)*,

  expr         = orExpr:e ( "?"   expr:t   ":" expr:f                                -> [#condExpr, e, t, f]
                          | "="   expr:rhs                                           -> [#set, e, rhs]
                          | "+="  expr:rhs                                           -> [#set, e, [#binop, "+", e, rhs]]
                          | "-="  expr:rhs                                           -> [#set, e, [#binop, "-", e, rhs]]
                          | "*="  expr:rhs                                           -> [#set, e, [#binop, "*", e, rhs]]
                          | "/="  expr:rhs                                           -> [#set, e, [#binop, "/", e, rhs]]
                          | "%="  expr:rhs                                           -> [#set, e, [#binop, "%", e, rhs]]
                          | "&&=" expr:rhs                                           -> [#set, e, [#binop, "&&", e, rhs]]
                          | "||=" expr:rhs                                           -> [#set, e, [#binop, "||", e, rhs]]
                          | "|="  expr:rhs                                           -> [#set, e, [#binop, "|", e, rhs]]
                          | "&="  expr:rhs                                           -> [#set, e, [#binop, "&", e, rhs]]
                          | "^="  expr:rhs                                           -> [#set, e, [#binop, "^", e, rhs]]
                          | ">>>="  expr:rhs                                         -> [#set, e, [#binop, ">>>", e, rhs]]
                          | ">>="  expr:rhs                                          -> [#set, e, [#binop, ">>", e, rhs]]
                          | "<<="  expr:rhs                                          -> [#set, e, [#binop, "<<", e, rhs]]
                          | empty                                                    -> e
                          ),
  orExpr       = orExpr:x "||" andExpr:y                                             -> [#binop, "||", x, y]
               | andExpr,
  andExpr      = andExpr:x "&&" bitExpr:y                                            -> [#binop, "&&", x, y]
               | bitExpr,
  bitExpr      = bitExpr:x "|" eqExpr:y                                              -> [#binop, "|", x, y]
               | bitExpr:x "^" eqExpr:y                                              -> [#binop, "^", x, y]
               | bitExpr:x "&" eqExpr:y                                              -> [#binop, "&", x, y]
               | eqExpr,
  eqExpr       = eqExpr:x ( "=="  relExpr:y                                          -> [#binop, "==",  x, y]
                          | "!="  relExpr:y                                          -> [#binop, "!=",  x, y]
                          | "===" relExpr:y                                          -> [#binop, "===", x, y]
                          | "!==" relExpr:y                                          -> [#binop, "!==", x, y]
                          )
               | relExpr,
  relExpr      = relExpr:x ( ">"          sftExpr:y                                  -> [#binop, ">",          x, y]
                           | ">="         sftExpr:y                                  -> [#binop, ">=",         x, y]
                           | "<"          sftExpr:y                                  -> [#binop, "<",          x, y]
                           | "<="         sftExpr:y                                  -> [#binop, "<=",         x, y]
                           | "instanceof" sftExpr:y                                  -> [#binop, "instanceof", x, y]
                           )
               | sftExpr,
  sftExpr      = sftExpr:x ">>>" addExpr:y                                           -> [#binop, ">>>",        x, y]
               | sftExpr:x ">>"  addExpr:y                                           -> [#binop, ">>",         x, y]
               | sftExpr:x "<<"  addExpr:y                                           -> [#binop, "<<",         x, y]
               | addExpr,
  addExpr      = addExpr:x "+" mulExpr:y                                             -> [#binop, "+",          x, y]
               | addExpr:x "-" mulExpr:y                                             -> [#binop, "-",          x, y]
               | mulExpr,
  mulExpr      = mulExpr:x "*" unary:y                                               -> [#binop, "*",          x, y]
               | mulExpr:x "/" unary:y                                               -> [#binop, "/",          x, y]
               | mulExpr:x "%" unary:y                                               -> [#binop, "%",          x, y]
               | unary,
  unary        = "-"      postfix:p                                                  -> [#unop,  "-",        p]
               | "+"      postfix:p                                                  -> [#unop,  "+",        p]
               | "++"     postfix:p                                                  -> [#set, p, [#binop, "+", p, [#number, 1]]]
               | "--"     postfix:p                                                  -> [#set, p, [#binop, "-", p, [#number, 1]]]
               | "!"      unary:p                                                    -> [#unop,  "!",        p]
               | "void"   unary:p                                                    -> [#unop,  "void",     p]
               | "delete" unary:p                                                    -> [#unop,  "delete",   p]
               | "typeof" unary:p                                                    -> [#unop,  "typeof",   p]
               | "~"      unary:p                                                    -> [#unop,  "~",        p]
               | postfix,
  postfix      = primExpr:p ( spacesNoNl ("++" -> "+"
                                         |"--" -> "-"):op                            -> [#begin, 
                                                                                            p,
                                                                                            [#code, _op("push", _EAX)],
                                                                                            [#set, p, [#binop, op, p, [#number, 1]]],
                                                                                            [#code, _op("pop", _EAX)]]
                            | empty                                                  -> p
                            ),
  primExpr     = primExpr:p ( "[@" expr:i "]"                                        -> [#gets, i, p]
                            | "["  expr:i "]"                                        -> [#getp, i, p]
                            | "." ("name":n
                                  | keyword:k -> k[0]):f                             -> [#getp, [#string, f], p]
                            | "(" listOf(#expr, ','):as ")"                          -> [#call, p].concat(as)
                            )
               | primExprHd,
  primExprHd   = "super" "(" expr:e ")"                                              -> [#super, e] 
               | "(" expr:e ")"                                                      -> e
               | "this"                                                              -> [#this]
               | "name":n                                                            -> [#get, n]
               | "number":n                                                          -> [#number, n]
               | "string":s                                                          -> [#string, s]
               | "eval":s                                                            -> eval(s)
               | "function" funcRest
               | "new" expr:e ?(e[0] === #call)                                      -> [#new, e[1]].concat(e.slice(2))
               | "[" listOf(#expr, ','):es "]"                                       -> [#arr].concat(es)
               | json,
  json         = "{" listOf(#jsonBinding, ','):bs "}"                                -> [#json].concat(bs),
  jsonBinding  = jsonPropName:n ":" expr:v                                           -> [#binding, n, v],
  jsonPropName = "name" | "number" | "string",
  formal       = spaces "name",
  funcRest     = "(" listOf(#formal, ','):fs ")" "{" srcElems:body "}"               -> [#func, fs, _new_context(), body],
  sc           = spacesNoNl ('\n' | &'}' | end)
               | ";",
  binding      = "name":n ( "=" expr
                          | empty -> [#get, 'undefined'] ):v                         -> [#var, n, v],
  block        = "{" srcElems:ss "}"                                                 -> ss,
  stmt         = block
               | ("var" | "const") listOf(#binding, ','):bs sc                       -> [#begin].concat(bs)
               | "if" "(" expr:c ")" stmt:t ( "else" stmt
                                            | empty -> [#get, 'undefined'] ):f       -> [#if, c, t, f]
               | "while" "(" expr:c ")" stmt:s                                       -> [#while,   c, s]
               | "do" stmt:s "while" "(" expr:c ")" sc                               -> [#doWhile, s, c]
               | "for" "(" ( ("var" | empty) listOf(#binding, ','):bs  -> [#begin].concat(bs)
                           | expr
                           | empty -> [#get, 'undefined'] ):i
                       ";" ( expr
                           | empty -> [#get, 'true']      ):c
                       ";" ( listOf(#expr, ','):es                     -> [#begin].concat(es)
                           | empty -> [#get, 'undefined'] ):u
                       ")" stmt:s                                                    -> [#for, i, c, u, s]
               | "for" "(" ( "var" binding
                           | expr                                             ):v
                      "in" expr:e
                       ")" stmt:s                                                    -> [#forIn, v, e, s]
               | "switch" "(" expr:e ")" "{"
                   ( "case" expr:c ":" srcElems:cs -> [#case, c, cs]
                   | "default"     ":" srcElems:cs -> [#default, cs] )*:cs
                 "}"                                                                 -> [#switch, e].concat(cs)
               | "break" sc                                                          -> [#break]
               | "continue" sc                                                       -> [#continue]
               | "throw" spacesNoNl expr:e sc                                        -> [#throw, e]
               | "try" block:t 
                    ("catch" "(" ("name":e | (empty -> undefined):e) ")" block:c
                             ( "finally" block
                             | empty -> [#get, 'undefined'] ):f
                    | "finally" block:f (empty -> [#get, 'undefined']):c (empty -> undefined):e)
                                                                                     -> [#try, _new_context, t, e, c, f]
               | "return" ( expr
                          | empty -> [#get, 'undefined'] ):e sc                      -> [#return, e]
               | "global_return" ( expr
                          | empty -> [#get, 'undefined'] ):e sc                      -> [#global_return, e]
               | "with" "(" expr:x ")" stmt:s                                        -> [#with, x, s]
               | expr:e sc                                                           -> e
               | ";"                                                                 -> [#get, "undefined"],
  srcElem      = "function" "name":n funcRest:f                                      -> {f[2].name = n; [#var, n, f]}
               | "macro" "name":n funcRest:f                                         -> [#macro, n].concat(f.slice(1))
               | stmt,
  srcElems     = srcElem*:ss                                                         -> [#begin].concat(ss),

  topLevel     = srcElems:r spaces end                                               -> [#global, _new_context(), r]
}
PhotonParser.hexDigits = "0123456789abcdef"
PhotonParser.keywords  = { }
keywords = ["break", "case", "catch", "continue", "default", "delete", "do", "else", "finally", "for", "function", "if", "in",
            "instanceof", "new", "return", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "ometa", "const", "global_return", "macro", "super"]
for (var idx = 0; idx < keywords.length; idx++)
  PhotonParser.keywords[keywords[idx]] = true
PhotonParser._isKeyword = function(k) { return this.keywords.hasOwnProperty(k) }

ometa PhotonASTTraversal {
  trans      = [:t apply(t):ans],
  curlyTrans = [#begin trans*:rs]
             | trans:r,


  global   :ctxt trans:r,
  this end,                                                  
  break end,                                                 
  continue end,
  number   :n,
  string   :s,
  arr      trans*:xs,
  unop     :op trans:x,
  getp     trans:fd trans:x,
  get      :x,
  set      trans:lhs trans:rhs,
  mset     trans:lhs :op trans:rhs,
  binop    :op trans:x trans:y,
  preop    :op trans:x,
  postop   :op trans:x,
  return   trans:x,
  with     trans:x curlyTrans:s,
  if       trans:cond curlyTrans:t curlyTrans:e,
  condExpr trans:cond trans:t trans:e,
  while    trans:cond curlyTrans:body,
  doWhile  curlyTrans:body trans:cond,
  for      trans:init trans:cond trans:upd
           curlyTrans:body,
  forIn    trans:x trans:arr curlyTrans:body,
  begin    trans:x end,
  begin    trans*:xs,
  func     :args :ctxt curlyTrans:body,  
  call     trans:fn trans*:args,
  ccall    trans:fn trans*:args,
  send     :msg trans:recv trans*:args,
  new      trans:fn trans*:args,
  var      :name trans:val,
  throw    trans:x,
  try      :ctxt curlyTrans:x :name curlyTrans:c curlyTrans:f,
  json     trans*:props,
  binding  :name trans:val,
  switch   trans:x trans*:cases,
  case     trans:x trans:y,
  default          trans:y,

  global_return    trans:x,
  ref      :s,
  gets     trans:fd trans:x,
  mreturn  trans:x trans:y,
  code     :c,
  super    trans:e,
  macro    :n :args :ctxt curlyTrans:body
}

ometa PhotonVarAnalysis <: PhotonASTTraversal {
  global   (:ctxt -> {ctxt.scope = scope(null); self._ctxt.push(ctxt);}) (trans:r -> {ctxt.scope.resolve(); /*print(ctxt.scope);*/}),
  get      (#true | #false | #undefined | #null),
  get      (:x -> {self.scope().use(x);}),
  func     :args 
           (:ctxt -> {ctxt.scope = scope(self.scope()); self._ctxt.push(ctxt); self.add_args(args);})
           (curlyTrans:body ->{self._ctxt.pop();}), 
  var      (:name -> {self.scope().declare(name, false);}) trans:val,
  try      :ctxt  curlyTrans:x 
           (:name        -> {ctxt.scope = catch_scope(self.scope(), name); self._ctxt.push(ctxt);}) 
           (curlyTrans:c -> {self._ctxt.pop();})
           curlyTrans:f
}

PhotonVarAnalysis.initialize = function () { 
    this._ctxt = []; 
    this.scope = function () { return this._ctxt[this._ctxt.length - 1].scope; };
    this.print_scope = function ()
    {
        for (var p in this.scope()) 
        { 
            print("var " + p + " is " + this.scope()[p]);
        } 
    };
    
    this.add_args = function (args)
    {
        for (var i = 0; i < args.length; ++i) 
        { 
            this.scope().declare(args[i], true);
        } 
    };
};


ometa PhotonCompiler {
  trans      = [:t apply(t):ans]     -> ans,
  curlyTrans = [#begin trans*:rs]    -> rs
             | trans:r               -> [r],

  // The global scope is not popped from context after matching
  global   (:ctxt -> {self.context.enter_function_scope(ctxt.scope, []); self.context.new_ref_ctxt();})  
           trans:r                                            -> [r, _op("ret")],
  this                                                        -> self.context.gen_get_this(),
  break                                                       -> _op("jmp", self.context.break_lbl()),
  continue                                                    -> _op("jmp", self.context.cont_lbl()),
  number   :n                                                 -> _op("mov", _$(_ref(n)), _EAX),  
  string   :s                                                 -> self.context.gen_symbol(s), 
  ref      :s (?(typeof s === "object" && 
                 s.__addr__ !== undefined))                   -> _op("mov", self.context.gen_mref(s), _EAX),
  arr      trans*:xs                                          -> self.context.gen_array(xs),
  get      ( #true      -> _$(_TRUE)
           | #false     -> _$(_FALSE)
           | #undefined -> _$(_UNDEFINED)
           | #null      -> _$(_NIL)):x                        -> _op("mov", x, _EAX),
  get      :x                                                 -> self.context.gen_get_var(x),
  getp     trans:fd trans:x                                   -> self.context.gen_send(x, self.context.gen_symbol("__get__"), [fd]),
  gets     trans:fd trans:x                                   -> [fd, _op("dec", _EAX), _op("push", _EAX), 
                                                                   x, _op("pop", _ECX), _op("mov", _mem(0, _EAX, _ECX, 2), _EAX)],
  set      [#get :x] trans:rhs                                -> self.context.gen_set_var(x, rhs),
  set      [#getp trans:fd trans:rcv] trans:rhs               -> self.context.gen_send(rcv, self.context.gen_symbol("__set__"), [fd, rhs]),
  set      [#gets trans:fd trans:rcv] trans:rhs               -> [rhs, _op("push", _EAX), 
                                                                  fd,  _op("dec", _EAX), _op("push", _EAX), 
                                                                  rcv, _op("mov", _EAX, _ECX),
                                                                  _op("pop", _EDX), 
                                                                  _op("pop", _EAX),
                                                                  _op("mov", _EAX, _mem(0, _ECX, _EDX, 2))],
  mset     trans:lhs :op trans:rhs                            -> {throw "Unimplemented mset '" + op + "'";},
  unop     ( '-'          -> [_op("push", _$(1)), 
                              self.context.gen_arith("sub"),
                              _op("inc", _EAX),
                              _op("add", _$(4), _ESP)]
           | '!'          -> [_op("cmp", _$(_TRUE), _EAX),
                              _op("mov", _$(_TRUE), _EAX),
                              _op("mov", _$(_FALSE), _ECX),
                              _op("cmovz", _ECX, _EAX)]):op 
             trans:x                                          -> [x, op],
  unop     ( 'typeof' trans:rcv                               -> self.context.gen_send(rcv, self.context.gen_symbol("__typeof__"), [])
           | 'delete' ([#getp trans:f trans:rcv]              -> self.context.gen_send(rcv, self.context.gen_symbol("__delete__"), [f])
                      |[#get :n]                              -> _op("mov", _$(_FALSE), _EAX))),

  binop    ( '+' -> "add"
           | '-' -> "sub"):op trans:x [#number :n]            -> [x, self.context.gen_arith_cste(op,  _$(n*2))],

  binop    ( '+'          -> [self.context.gen_arith("add", true), _op("dec", _EAX)]     
           | '-'          -> [self.context.gen_arith("sub", false), _op("inc", _EAX)]    
           | '*'          -> self.context.gen_arith_mul()    
           | '/'          -> self.context.gen_arith_div(false)
           | '%'          -> self.context.gen_arith_div(true)
           | '<'          -> self.context.gen_rel("cmovl", true)                         
           | '<='         -> self.context.gen_rel("cmovle", true)                       
           | '>'          -> self.context.gen_rel("cmovnle", true)                       
           | '>='         -> self.context.gen_rel("cmovnl", true)                        
           | '=='         -> []                                          
           | '!='         -> []                                          
           | '==='        -> self.context.gen_rel("cmovz", false)                        
           | '!=='        -> self.context.gen_rel("cmovnz", false)                       
           | '>>'         -> self.context.gen_shiftop("sar")                             
           | '>>>'        -> self.context.gen_shiftop("shr")                             
           | '<<'         -> self.context.gen_shiftop("sal")                             
           | '^'          -> self.context.gen_bitwise("xor")                                         
           | '&'          -> self.context.gen_bitwise("and")                                          
           | '|'          -> self.context.gen_bitwise("or")):op                                          
           trans:x trans:y                                    -> [x, _op("push", _EAX), y, op, _op("add", _$(4), _ESP)],
  binop    ( '||' (empty -> _TRUE):skip  -> self.context.gen_logic("or")
           | '&&' (empty -> _FALSE):skip -> self.context.gen_logic("and")):op  
           trans:x trans:y                                    -> {var END = _label();
                                                                  [x, _op("cmp", _$(skip), _EAX), _op("je", END),
                                                                   _op("push", _EAX), y, op, _op("add", _$(4), _ESP), END]},
  binop      'instanceof' trans:x trans:y                     -> self.context.gen_send(x, self.context.gen_symbol("__instanceof__"), [y]),
  preop    :op trans:x                                        -> {throw "Unimplemented preop '" + op + "'";},
  postop   :op trans:x                                        -> {throw "Unimplemented postop '" + op + "'";},
  return   trans:x                                            -> [x, self.context.gen_epilogue()],
  with     trans:x curlyTrans:s                               -> {throw "Unimplemented with statement"},
  if       (empty -> _label()):FALSE 
           ([#binop ('<'   -> "jge"
                    |'<='  -> "jg"
                    |'>'   -> "jle"
                    |'>='  -> "jl"):jcc
               trans:x ([#number :n] -> [self.context.gen_type_check(1), _op("cmp", _$(_ref(n)), _EAX)]
                       | trans:y     -> [_op("push", _EAX), y, self.context.gen_type_check(2), 
                                         _op("cmp", _EAX, _mem(0, _ESP)), _op("pop", _EAX)]):cmp]    
                                            -> [x, cmp, _op(jcc, FALSE)]
           | trans:cond                     -> [cond, _op("cmp", _$(_TRUE), _EAX), _op("jne", FALSE)]):cond                      
           curlyTrans:t curlyTrans:e                          -> {var END = _label(); 
                                                                  [cond, _listing("TRUE:"), 
                                                                         t, _op("jmp", END), FALSE, _listing("FALSE:"), 
                                                                         e, END, _listing("END:")];},
  condExpr trans:cond trans:t trans:e                         -> {var END   = _label(); 
                                                                  var FALSE = _label();
                                                                 [cond, _op("cmp", _$(_TRUE), _EAX), 
                                                                  _op("jne", FALSE),
                                                                     t, _op("jmp", END), FALSE, 
                                                                     e, END, _listing("END:")];},
  while    (empty -> self.context.push_block())
           trans:cond curlyTrans:body                         -> {var LOOP = _label(); var END = _label();
                                                                  var CONT = self.context.cont_lbl(); var BREAK = self.context.break_lbl();
                                                                  self.context.pop_block();
                                                                  [LOOP, CONT,
                                                                   cond, _op("cmp", _$(_TRUE), _EAX), _op("jne", END),
                                                                         body, _op("jmp", LOOP), BREAK, END]},
  doWhile  (empty -> self.context.push_block())
           curlyTrans:body trans:cond                         -> {var LOOP = _label(); var END = _label();
                                                                  var CONT = self.context.cont_lbl(); var BREAK = self.context.break_lbl();
                                                                  self.context.pop_block();
                                                                  [LOOP, CONT, body, cond, _op("cmp", _$(_TRUE), _EAX), _op("je", LOOP), 
                                                                   BREAK, END]},
  for      (empty -> self.context.push_block()) 
           trans:init trans:cond trans:upd
           curlyTrans:body                                    -> {var LOOP = _label(); var END = _label();
                                                                  var CONT = self.context.cont_lbl(); var BREAK = self.context.break_lbl();
                                                                  self.context.pop_block();
                                                                  [init, LOOP, cond, _op("cmp", _$(_TRUE), _EAX), _op("jne", END),
                                                                         body, CONT, upd, _op("jmp", LOOP), BREAK, END]},
  forIn    trans:x trans:arr curlyTrans:body                  -> [],
  begin    trans:x end                                        -> [x],
  begin    trans*:xs                                          -> xs,
  func     (:args :ctxt  -> {self.context.enter_function_scope(ctxt.scope, args);  self.context.new_ref_ctxt();})
           curlyTrans:body                                    -> {var f = self.context.new_js_function_object(ctxt.name, args, body); 
                                                                  var offsets = self.context.closure_offsets;
                                                                  self.context.leave_function_scope();
                                                                  self.context.pop_ref_ctxt();
                                                                  self.context.gen_closure(f, ctxt.scope, offsets);},
  send     trans:msg trans:rcv trans*:args                    -> self.context.gen_send(rcv, msg, args, photon.bind),
  call     [#getp trans:msg [#super trans:rcv]] trans*:args   -> self.context.gen_send(rcv, msg, args, photon.super_bind),
  call     [#getp trans:msg trans:rcv]  trans*:args           -> self.context.gen_send(rcv, msg, args, photon.bind),
  call     trans:fn trans*:args                               -> self.context.gen_call(fn, args),
  new      trans:cls trans*:args                              -> self.context.gen_new(cls, args),
  var      :name trans:val                                    -> self.context.gen_set_var(name, val),
  throw    trans:x                                            -> self.context.gen_throw(x),
  try      :ctxt (empty -> self.context.enter_try_block()) curlyTrans:x 
           (:name -> { self.context.leave_try_block(); self.context.enter_catch_scope(ctxt.scope);})
           curlyTrans:c (empty -> self.context.leave_catch_scope())
           ([#get #undefined] | curlyTrans -> {throw "Unsupported finally block";})                                       
                                                              -> self.context.gen_try_catch(x, c, ctxt.scope),
  json     trans*:props                                       -> self.context.gen_object(props),
  binding  :name trans:val                                    -> [name, val],
  switch   (empty -> self.context.push_block()) 
           trans:x trans*:cases                               -> {var BREAK = self.context.break_lbl(); self.context.pop_block();
                                                                  [x, _op("push", _EAX), cases, BREAK, _op("add", _$(4), _ESP)]},
  case     trans:x trans:y                                    -> {var END = _label();
                                                                 [x, _op("cmp", _mem(0, _ESP), _EAX), _op("jne", END), y, END]},
  default          trans:y                                    -> [y],

  // Extensions
  ccall    trans:fn trans*:args                               -> [self.context.gen_push_args(args),
                                                                  fn, _op("call", _EAX), 
                                                                  self.context.gen_pop_args(args.length)],
  global_return   trans:x                                     -> [x, _op("ret")],
  mreturn  trans:x trans:y                                    -> [x, _op("push", _EAX), y, _op("mov", _EAX, _ECX), _op("pop", _EAX), 
                                                                  self.context.gen_epilogue()],
  code     :c                                                 -> c
}

PhotonCompiler.initialize = function ()
{
    this.context = PhotonCompiler.context.init();
};

PhotonCompiler.context = {init:function () { print("Invalid context"); }};

